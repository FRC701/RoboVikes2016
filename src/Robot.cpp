// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "SmartDashboard/SmartDashboard.h"

#include "Subsystems/Shooter.h"

#include "Commands/AutoDrive.h"
#include "Commands/IntakeArmLevel.h"
#include "Commands/IntakeOn.h"
#include "Commands/RollerOn.h"
#include "Commands/ShooterControl.h"
#include "Commands/IntakeArmOn.h"
#include "Commands/AutoTurn.h"
#include "Commands/ShooterRollerIntakeOn.h"
#include "Commands/IntakeOn.h"
#include "Commands/AutoLowBar.h"
#include "Commands/AutoRampart.h"
#include "Commands/AutoRockWall.h"
#include "Commands/AutoMoat.h"
#include "Commands/ShifterToggle.h"
#include "Commands/PrepShooter.h"
#include "Commands/PopBall.h"
#include "Commands/FullIntake.h"
#include "Commands/AutoLowBarShoot.h"
#include "Commands/SetShifter.h"
#include "Commands/AutoTurn.h"
#include "Commands/ToggleShooter.h"
#include "Commands/KickstandToggle.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Chassis> Robot::chassis;
std::shared_ptr<Intake> Robot::intake;
std::shared_ptr<Shooter> Robot::shooter;
std::unique_ptr<OI> Robot::oi;
std::shared_ptr<Lights> Robot::lights;
std::shared_ptr<SendableChooser> Robot::chooser;
//std::shared_ptr<Preferences> Robot::preferences;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

/**
 * Initialize items for the smartdashboard
 *
 * These items only need to be added to the smartdashboard once.
 */

void SmartDashboardInit() {
	//Test
	//SmartDashboard::PutData("AutoDrive", new AutoDrive(Preferences::GetInstance()->GetInt("Auto Drive Distance", 0)));
	SmartDashboard::PutData("AutoTurn Right", new AutoTurn(AutoTurn::turnRight,Preferences::GetInstance()->GetInt("AutoTurn Distance R", 0)));
	SmartDashboard::PutData("AutoTurn Left", new AutoTurn(AutoTurn::turnLeft,Preferences::GetInstance()->GetInt("AutoDrive Distance L", 0)));
	SmartDashboard::PutData("Shooter Control", new ShooterControl(Preferences::GetInstance()->GetDouble("Shooter Control Speed", 0)));
	SmartDashboard::PutData("Intake On", new ShooterRollerIntakeOn(Preferences::GetInstance()->GetDouble("Intake On Speed (percentage)", 0.0)));
	SmartDashboard::PutData("Intake On ONLY", new IntakeOn(Preferences::GetInstance()->GetDouble("Intake On ONLY Speed (percentage)", 0.0)));
	SmartDashboard::PutData("Arm Level Intake", new IntakeArmLevel(IntakeArmLevel::ArmLevelPosition_Intake));
	SmartDashboard::PutData("Arm Level Porculis", new IntakeArmLevel(IntakeArmLevel::ArmLevelPosition_Portculis));
	SmartDashboard::PutData("Arm Level Scale", new IntakeArmLevel(IntakeArmLevel::ArmLevelPosition_Scale));

	//Buttons
	SmartDashboard::PutData("ShifterToggle", new ShifterToggle());
    //SmartDashboard::PutData("TankDrive", new TankDrive());

    //running commands and motors
    SmartDashboard::PutData("Shooter Control", new ShooterControl (6000));
    SmartDashboard::PutData("Roller On", new RollerOn(1.0));
    SmartDashboard::PutData("Intake On", new IntakeOn(1.0));
    SmartDashboard::PutData("Intake Arm Down", new IntakeArmOn(1.0));

    SmartDashboard::PutData("PrepShooter", new PrepShooter());
    SmartDashboard::PutData("PopBall", new PopBall());
    SmartDashboard::PutData("Full Intake", new FullIntake(-1.0,-1.0));

    //Test
    SmartDashboard::PutData("Set Low Gear", new SetShifter('l'));
    SmartDashboard::PutData("Set High Gear", new SetShifter('h'));
    SmartDashboard::PutData("Auto Turn Left",
    		new AutoTurn(AutoTurn::turnLeft,Preferences::GetInstance()->GetInt("Auto Turn Value", 0)));
    SmartDashboard::PutData("Shooter Control",
    		new ShooterControl(Preferences::GetInstance()->GetInt("Shooter Control Speed", 0)));
    SmartDashboard::PutData("Shooter Toggle", new ToggleShooter());
}

void SmartDashboardPeriodic () {
	//Current of all the motors
		//	/*
	/*SmartDashboard::PutNumber("Current: LeftChassis 1", RobotMap::chassisleftMotor1->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: LeftChassis 2", RobotMap::chassisleftMotor2->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: LeftChassis 3", RobotMap::chassisleftMotor3->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: RightChassis 1", RobotMap::chassisrightMotor1->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: RightChassis 1", RobotMap::chassisrightMotor2->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: RightChassis 1", RobotMap::chassisrightMotor3->GetOutputCurrent());
	SmartDashboard::PutNumber("Currrent:Shooter Roller", RobotMap::shooterrollerMotor->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Shooter Left", RobotMap::shootershooterMotor1->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Shooter Right", RobotMap::shootershooterMotor2->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Intake In", RobotMap::intakeintakeMotor1->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Intake Side", RobotMap::intakeintakeMotor2->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Intake Arm Right", RobotMap::intakeintakeMotor3->GetOutputCurrent());
	SmartDashboard::PutNumber("Current: Intake Arm Left", RobotMap::intakeintakeMotor4->GetOutputCurrent());

	//voltage of the arm motors
	SmartDashboard::PutNumber("Intake Motor 3 Out Volts", RobotMap::intakeintakeMotor3->GetOutputVoltage()
			/RobotMap::intakeintakeMotor3->GetBusVoltage());
	SmartDashboard::PutNumber("Intake Motor 4 Out Volts", RobotMap::intakeintakeMotor4->GetOutputVoltage()
			/RobotMap::intakeintakeMotor4->GetBusVoltage());

	//Output current of the arms
	SmartDashboard::PutNumber("Intake Motor 3 Out Current", RobotMap::intakeintakeMotor3->GetOutputCurrent());
	SmartDashboard::PutNumber("Intake Motor 4 Out Current", RobotMap::intakeintakeMotor4->GetOutputCurrent());


	//encoder position for the motors
	SmartDashboard::PutNumber("Left Encoder", RobotMap::chassisleftMotor1->GetPosition());
	SmartDashboard::PutNumber("Right Encoder", RobotMap::chassisrightMotor1->GetPosition());
	SmartDashboard::PutNumber("IntakeMotor3 Enc Pos", RobotMap::intakeintakeMotor3->GetEncPosition());
	SmartDashboard::PutNumber("IntakeMotor4 Enc Pos", RobotMap::intakeintakeMotor4->GetEncPosition());
	SmartDashboard::PutNumber("LEFT AUTO CHASSIS ENC POS", RobotMap::chassisleftMotor1->GetEncPosition());
	SmartDashboard::PutNumber("RIGHT AUTO CHASSIS ENC POS", RobotMap::chassisrightMotor1->GetEncPosition());
	SmartDashboard::PutNumber("LEFT AUTO CHASSIS POS", RobotMap::chassisleftMotor1->GetPosition());
	SmartDashboard::PutNumber("RIGHT AUTO CHASSIS POS", RobotMap::chassisrightMotor1->GetPosition());
	SmartDashboard::PutNumber("LEFT AUTO CHASSIS VEL", RobotMap::chassisleftMotor1->GetEncVel());
	SmartDashboard::PutNumber("RIGHT AUTO CHASSIS VEL", RobotMap::chassisrightMotor1->GetEncVel());
	SmartDashboard::PutNumber("LEFT AUTO CHASSIS PULSE POS", RobotMap::chassisleftMotor1->GetPulseWidthPosition());
	SmartDashboard::PutNumber("RIGHT AUTO CHASSIS PULSE POS", RobotMap::chassisrightMotor1->GetPulseWidthPosition());
*/

    SmartDashboard::PutNumber("Shooter Speed", RobotMap::shootershooterMotor1->GetSpeed());
    SmartDashboard::PutNumber("Shooter Speed2", RobotMap::shootershooterMotor2->GetSpeed());

	SmartDashboard::PutNumber("IntakeMotor3 Pos", RobotMap::intakeintakeMotor3->GetPosition());
	SmartDashboard::PutNumber("IntakeMotor4 Pos", RobotMap::intakeintakeMotor4->GetPosition());
	SmartDashboard::PutNumber("IntakeMotor3 Pulse Width Pos", RobotMap::intakeintakeMotor3->GetPulseWidthPosition());
	SmartDashboard::PutNumber("IntakeMotor4 Pulse Width Pos", RobotMap::intakeintakeMotor4->GetPulseWidthPosition());

	SmartDashboard::PutNumber("Voltage LeftArm", RobotMap::intakeintakeMotor3->GetOutputCurrent());
	SmartDashboard::PutNumber("Voltage RightArm", RobotMap::intakeintakeMotor4->GetOutputCurrent());
}


void Robot::RobotInit() {

	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    chassis.reset(new Chassis());
    intake.reset(new Intake());
    shooter.reset(new Shooter());
    lights.reset(new Lights());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	//CameraServer::GetInstance()->SetQuality(50);
	//CameraServer::GetInstance()->StartAutomaticCapture("cam1");

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	//autonomousCommand.reset(new AutonomousCommand());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	chooser.reset(new SendableChooser());
	chooser->AddDefault("Low Bar", new AutoLowBar());
	chooser->AddObject("Rough Terrain/ Rampart", new AutoRampart());
	chooser->AddObject("Rock Wall", new AutoRockWall());
	chooser->AddObject("Moat", new AutoMoat());
	chooser->AddObject("Portcullis/Cheval de Frise", new AutoDrive(AutoDrive::Distance_Reach));
	chooser->AddObject("Reach", new AutoDrive(AutoDrive::Distance_Reach));
	chooser->AddObject("Do Nothing", new AutoDrive(AutoDrive::Distance_DoNothing));
	chooser->AddObject("LowBarShoot", new AutoLowBarShoot());
	SmartDashboard::PutData("Autonomous modes", chooser.get());

	RobotMap::lightsfeatureLights->Set(Relay::kForward);

	//RobotMap::shooterliftShooter->Set(DoubleSolenoid::kForward);

	SmartDashboardInit();
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	autonomousCommand.reset((Command *) chooser->GetSelected());
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();

//	RobotMap::chassiskickstand->Set(DoubleSolenoid::kForward);
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();

	//Setting starting values of Pneumatics......................
	RobotMap::chassisshift->Set(DoubleSolenoid::kReverse);
	RobotMap::shooterliftShooter->Set(DoubleSolenoid::kReverse);
	RobotMap::lightsfeatureLights->Set(Relay::kForward);

}

void Robot::nudgeShooter() {
	int prepShooterSpeed = shooter->getPrepShooterSpeed();

	if (Robot::oi->getcoDriver()->GetPOV(0) == 0)
    	prepShooterSpeed += 5;
    else if(Robot::oi->getcoDriver()->GetPOV(0) == 90)
    	prepShooterSpeed += 10;
    else if(Robot::oi->getcoDriver()->GetPOV(0) == 180)
    	prepShooterSpeed -= 5;
    else if(Robot::oi->getcoDriver()->GetPOV(0) == 270)
        prepShooterSpeed -= 10;

    if (prepShooterSpeed > 6000)
    	prepShooterSpeed = 6000;
    else if (prepShooterSpeed < 0)
    	prepShooterSpeed = 0;
    shooter->setPrepShooterSpeed(prepShooterSpeed);
}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();

	SmartDashboardPeriodic();

	if(RobotMap::shooterrollerMotor->IsFwdLimitSwitchClosed())
		RobotMap::lightsshooterLight->Set(Relay::kForward);
	else
		RobotMap::lightsshooterLight->Set(Relay::kReverse);

	nudgeShooter();
}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

